import matplotlib.pyplot as plt
import numpy as np
t = np.arange(0.0, 2.0, 0.01)
s = 1 + np.sin(2*np.pi*t)
plt.plot(t, s)
plt.xlabel('time (s)')
plt.ylabel('voltage (mv)')
plt.grid(True)
plt.savefig("test.png")
plt.show()
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
use_python("/usr/bin/python3")
reticulate::repl_python()
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
knitr::knit_engines$set(python = reticulate::eng_python)
reticulate::repl_python()
reticulate::repl_python()
ls()
py_install("pandas")
sin(pi)
runif(100)
x
y
py$t
py$s
example("read.csv")
vignette("ggplot2")
digoxin <- read.csv("Digoxin.csv", header = T)
str(digoxin)
digoxin$Visit <- as.Date(digoxin$Visit, format = "%m/%d/%y")
library(xtable)
#print first 10 lines only
print(xtable(head(digoxin,10), align = c("l","c","c","r","r")),
type="html", include.rownames=FALSE)
#First change a factor to a character vector, then a numeric one
digoxin$Weight <- as.numeric(as.character(digoxin$Weight))
#Next, the first element of the vector is now NA due to the improper formating; fix this by
#inserting the proper value
digoxin$Weight[1] <- 70
#Finally, check the structure again:
str(digoxin)
library(ggplot2)
g <- ggplot(data=digoxin, aes(x=Visit, y=mM_Digoxin, group = Subject))
#note plus sign at end of line to add a linebreak in the ggplot command
g + geom_line(aes(color = Subject)) + theme_bw() + ylab("mM digoxin") + xlab("Visit (time)") +
ggtitle("Digoxin Levels over Time")
m1 <- lm(mM_Digoxin ~ Weight + I(sin(2*pi/30*as.numeric(Visit))), data=digoxin)
summary(m1)
m2 <- lm(mM_Digoxin ~ Weight + I(sin(2*pi/30*as.numeric(Visit))) - 1, data=digoxin)
summary(m2)
anova(m1,m2) #m2 would be favored
plot(m2)
reticulate::repl_python()
example_1_2_5  <- function(t, k, Ta) t + k*(Ta - t)
### Vary k and Ta across 6 different levels and plot solutions
### Vary k from 0.01 to 0.1 at the log-scale; Vary Ta from 60 to 80
### Plot 100 time points
### Create plots based each level of k (i.e., 6 lines per plot)
### With the unique plots for each k, create a large plot with 6 facets
### Commands needed: exp(), log(), seq(), rep(), ggplot()+++, rbind(),
k <- exp(seq(log(0.01), log(0.1), length=6))
Ta <- seq(60, 80, length = 6)
library(ggplot2)
allData <- data.frame(rate = 0, Ta = 0, Time = 0, temp = 0)
allData <- allData[0,]
for(rate in k){
rateData <- data.frame(Ta = 0, Time = 0, temp=0)
rateData <- rateData[0,]
for(ta in Ta){
rateData <- rbind(rateData,
data.frame(
Ta = rep(ta, 100),
Time = 1:100,
temp = recur(function(x) example_1_2_5(x, rate, ta), 40, 100, val= T)[-1]
)
)
}
g <- ggplot(rateData, aes(x=Time, y=temp, group = Ta, color = Ta))
g <- g + geom_line() + theme_bw() + ylab("Temperature") +
scale_color_gradient(name="Ambient\nTemperature", low="darkblue", high="red") +
ggtitle(paste("Rate =", round(rate,3), sep=" "))
print(g)
rateData$rate = rate
allData <- rbind(allData, rateData)
}
recur <- function(f,f0,k,verbose=F,values = F){
ret <- rep(NA,k+1)
ret[1] <- f0
for(i in 2:(k+1)) ret[i] <- f(ret[i-1])
if(verbose) print(ret)
if(values) return(ret)
ret[k+1]
}
allData <- data.frame(rate = 0, Ta = 0, Time = 0, temp = 0)
allData <- allData[0,]
for(rate in k){
rateData <- data.frame(Ta = 0, Time = 0, temp=0)
rateData <- rateData[0,]
for(ta in Ta){
rateData <- rbind(rateData,
data.frame(
Ta = rep(ta, 100),
Time = 1:100,
temp = recur(function(x) example_1_2_5(x, rate, ta), 40, 100, val= T)[-1]
)
)
}
g <- ggplot(rateData, aes(x=Time, y=temp, group = Ta, color = Ta))
g <- g + geom_line() + theme_bw() + ylab("Temperature") +
scale_color_gradient(name="Ambient\nTemperature", low="darkblue", high="red") +
ggtitle(paste("Rate =", round(rate,3), sep=" "))
print(g)
rateData$rate = rate
allData <- rbind(allData, rateData)
}
reticulate::repl_python()
reticulate::repl_python()
recur <- function(f,f0,k,verbose=F,values = F){
ret <- rep(NA,k+1)
ret[1] <- f0
for(i in 2:(k+1)) ret[i] <- f(ret[i-1])
if(verbose) print(ret)
if(values) return(ret)
ret[k+1]
}
myfun <- function(x) x * 2
recur(myfun, 2, 10)
recur(myfun, 2, 10, verb=T)
recur(myfun, 2, 10, val=T)
###----------Example 1.2.5: Heat Transfer
# âˆ†t = k(T - t)
# t0 = 40
# Ta is the ambient temperature
example_1_2_5  <- function(t, k, Ta) t + k*(Ta - t)
### Vary k and Ta across 6 different levels and plot solutions
### Vary k from 0.01 to 0.1 at the log-scale; Vary Ta from 60 to 80
### Plot 100 time points
### Create plots based each level of k (i.e., 6 lines per plot)
### With the unique plots for each k, create a large plot with 6 facets
### Commands needed: exp(), log(), seq(), rep(), ggplot()+++, rbind(),
k <- exp(seq(log(0.01), log(0.1), length=6))
Ta <- seq(60, 80, length = 6)
library(ggplot2)
allData <- data.frame(rate = 0, Ta = 0, Time = 0, temp = 0)
allData <- allData[0,]
for(rate in k){
rateData <- data.frame(Ta = 0, Time = 0, temp=0)
rateData <- rateData[0,]
for(ta in Ta){
rateData <- rbind(rateData,
data.frame(
Ta = rep(ta, 100),
Time = 1:100,
temp = recur(function(x) example_1_2_5(x, rate, ta), 40, 100, val= T)[-1]
)
)
}
g <- ggplot(rateData, aes(x=Time, y=temp, group = Ta, color = Ta))
g <- g + geom_line() + theme_bw() + ylab("Temperature") +
scale_color_gradient(name="Ambient\nTemperature", low="darkblue", high="red") +
ggtitle(paste("Rate =", round(rate,3), sep=" "))
print(g)
rateData$rate = rate
allData <- rbind(allData, rateData)
}
g <- ggplot(allData, aes(x=Time, y=temp, group = Ta, color = Ta))
g + geom_line() + theme_bw() + ylab("Temperature") +
scale_color_gradient(name="Ambient\nTemperature", low="darkblue", high="red") +
ggtitle("Changes in Temperature over Time, Ambient Temperature, and Rate") +
facet_wrap(vars(rate), labeller = labeller(rate = function(x) paste("k = ", round(as.numeric(x),3), sep="")))
recur <- function(f,f0,k,verbose=F,values = F){
ret <- rep(NA,k+1)
ret[1] <- f0
for(i in 2:(k+1)) ret[i] <- f(ret[i-1])
if(verbose) print(ret)
if(values) return(ret)
ret[k+1]
}
myfun <- function(x) x * 2
recur(myfun, 2, 10)
recur(myfun, 2, 10, verb=T)
recur(myfun, 3, 10, verb=T)
recur(myfun, 2, 10, val=T)
v1 <- recur(myfun, 2, 10, val=T)
v2 <- recur(myfun, 2, 10)
v2 <- recur(myfun, 2, 10, verb = T)
reticulate::repl_python()
k <- exp(seq(log(0.01), log(0.1), length=6))
Ta <- seq(60, 80, length = 6)
library(ggplot2)
allData <- data.frame(rate = 0, Ta = 0, Time = 0, temp = 0)
allData <- allData[0,]
for(rate in k){
rateData <- data.frame(Ta = 0, Time = 0, temp=0)
rateData <- rateData[0,]
for(ta in Ta){
rateData <- rbind(rateData,
data.frame(
Ta = rep(ta, 100),
Time = 1:100,
temp = recur(function(x) example_1_2_5(x, rate, ta), 40, 100, val= T)[-1]
)
)
}
g <- ggplot(rateData, aes(x=Time, y=temp, group = Ta, color = Ta))
g <- g + geom_line() + theme_bw() + ylab("Temperature") +
scale_color_gradient(name="Ambient\nTemperature", low="darkblue", high="red") +
ggtitle(paste("Rate =", round(rate,3), sep=" "))
print(g)
rateData$rate = rate
allData <- rbind(allData, rateData)
}
example_1_2_5  <- function(t, k, Ta) t + k*(Ta - t)
for(rate in k){
rateData <- data.frame(Ta = 0, Time = 0, temp=0)
rateData <- rateData[0,]
for(ta in Ta){
rateData <- rbind(rateData,
data.frame(
Ta = rep(ta, 100),
Time = 1:100,
temp = recur(function(x) example_1_2_5(x, rate, ta), 40, 100, val= T)[-1]
)
)
}
g <- ggplot(rateData, aes(x=Time, y=temp, group = Ta, color = Ta))
g <- g + geom_line() + theme_bw() + ylab("Temperature") +
scale_color_gradient(name="Ambient\nTemperature", low="darkblue", high="red") +
ggtitle(paste("Rate =", round(rate,3), sep=" "))
print(g)
rateData$rate = rate
allData <- rbind(allData, rateData)
}
g <- ggplot(allData, aes(x=Time, y=temp, group = Ta, color = Ta))
g + geom_line() + theme_bw() + ylab("Temperature") +
scale_color_gradient(name="Ambient\nTemperature", low="darkblue", high="red") +
ggtitle("Changes in Temperature over Time, Ambient Temperature, and Rate") +
facet_wrap(vars(rate), labeller = labeller(rate = function(x) paste("k = ", round(as.numeric(x),3), sep="")))
reticulate::repl_python()
reticulate::repl_python()
library(reticulate)
py_config()
reticulate::repl_python()
py_install("pandas")
reticulate::repl_python()
py_install("matplotlib")
reticulate::repl_python()
reticulate::repl_python()
dMat <- data.frame("Criteria" = c("Chebysev", "Mean Absolute Deviation", "Least Squares",
"Median Absolute Deviation", "Maximum Likelihood"),
"Distance" = c((t(ChebyFit$par) %*% c(3,5))^0.5, (t(MeanADFit$par) %*% c(3,5))^0.5,
(t(LSQFit$par) %*% c(3,5))^0.5, (t(MedianADFit$par) %*% c(3,5))^0.5,
(t(LLFit$par) %*% c(3,5))^0.5))
dMat[order(dMat$Distance),]
objFns <- c("chebyshev","leastSq","llnorm","meanAD","medianAD")
algs <- c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN")
vals <- matrix(NA, ncol = length(objFns), nrow = length(algs))
colnames(vals) <- objFns
rownames(vals) <- algs
for(i in 1:length(objFns)){
clist <- if(objFns[i] == "llnorm") list(fnscale = -1) else list()
for(j in 1:length(algs)) vals[j,i]<-optim(guess, objectiveFn, xvals = x, yvals = y,
dist = objFns[i], method = algs[j], control = clist)$value
}
vals
plot(lagrange(seq(-8,8,by=0.01), sample(-8:8), rep(0.01,17)), type="l", xlab="x", ylab="y", main = "High Order Approximation", lwd = 2, col="blue")
#z is the point to evaluate at
#x is the x data
#y is the y data
#i is index of the polynomial, i.e., L_k=L_i
Lk <- function(z, x, y){
sub <- rep(NA, length(x))
for(i in seq_along(sub)) sub[i]  <- y[i]*prod(z - x[-i]) / prod(x[i] - x[-i])
sum(sub)
}
#v are values to evaluate the polynomial at
#x and y are the data
lagrange  <- function(v,x,y){
if(length(x) != length(y)) return(print("Error: x and y have different lengths."))
Px <- rep(NA, length(v))
v <- sort(v)
for(i in seq_along(v)) Px[i] <- Lk(v[i],x,y)
out <- matrix(c(v, Px), ncol = 2)
out
}
### Book Figure 4.12
plot(lagrange(seq(-8,8,by=0.01), sample(-8:8), rep(0.01,17)), type="l", xlab="x", ylab="y", main = "High Order Approximation", lwd = 2, col="blue")
points(-8:8, rep(0.01,17), col="red", cex=2, pch=20)
plot(lagrange(seq(0,4,by=0.05), c(0, 2, 3, 4), c(7, 11, 28, 63)), type = "l", xlab="x", ylab="y", col="blue", lwd=2)
points(c(0, 2, 3, 4), c(7, 11, 28, 63), col="red", cex=2, pch=20)
# x data
set.seed(19624)
x <- sort(runif(20,-5,5)) #note the sorting
y <- 2*x^3 - 5*x^2 + x + 5
# y with (small) noise
y.noise <- y + rnorm(20,0,0.2)
first <- diff(y)/diff(x)
second <- diff(first)/diff(x,lag=2)
third <- diff(second)/diff(x,lag=3)
fourth <- diff(third)/diff(x,lag=4)
data.frame(first, second = c(0,second), third = c(0,0,third), fourth = c(0,0,0,fourth))
first <- diff(y.noise)/diff(x)
second <- diff(first)/diff(x,lag=2)
third <- diff(second)/diff(x,lag=3)
fourth <- diff(third)/diff(x,lag=4)
data.frame(first, second = c(0,second), third = c(0,0,third), fourth = c(0,0,0,fourth))
fifth <- diff(fourth)/diff(x,lag=5)
sixth<- diff(fifth)/diff(x,lag=6)
seventh<- diff(sixth)/diff(x,lag=7)
fourth
fifth
sixth
seventh
par(mfrow = c(3,2))
plot(first, type="l",lwd=2,col="blue")
plot(second, type="l",lwd=2,col="blue")
plot(third, type="l",lwd=2,col="blue")
plot(fourth, type="l",lwd=2,col="blue")
plot(fifth, type="l",lwd=2,col="blue")
plot(sixth, type="l",lwd=2,col="blue")
set.seed(8652)
x <- sort(runif(200,-5,5)) #note the sorting
y <- 2*x^3 - 5*x^2 + x + 5
# y with (small) noise
y.noise <- y + rnorm(200,0,50)
plot(x, y.noise, ylab="y")
s1 <- smooth.spline(x,y.noise)
m1 <- predict(s1, x)
plot(x, y.noise, ylab="y", main = "Default Smoothed Spline")
points(m1, col="red", type="l", lwd = 2)
s1$spar #how much smothing was done?
s1$fit$knot #see how many knots and where, note these are scaled between xmin and xmax
s2 <- smooth.spline(x,y.noise, nknots = 6, spar = 0.1)
m2 <- predict(s2, x)
plot(x, y.noise, ylab="y", main="Spline with 6 knots")
points(m2, col="red", type="l", lwd = 2)
abline(v = unique(s2$fit$knot) * diff(range(x)) + min(x), col="blue", lty = 2, lwd = 2)
table(cut(x, unique(s2$fit$knot) * diff(range(x)) + min(x), include.lowest=T))
s3 <- smooth.spline(x,y.noise, all.knots = seq(0,1,length=6), spar = 0.1)
m3 <- predict(s3, x)
plot(x, y.noise, ylab="y", main="Spline with 6 evenly spaced knots")
points(m3, col="red", type="l", lwd = 2)
abline(v = unique(s3$fit$knot) * diff(range(x)) + min(x), col="blue", lty = 2, lwd = 2)
knitr::kable(reticulate::py$strategy)
rho <- 0.02
A <- 69
Z <- 1
data <- data.frame(Time=0, A = A, Z = Z)
for(i in 1:100){
DeltaA <- -rho*A*(Z/70)^0.5
DeltaZ <- rho*A*(Z/70)^0.5 - Z/15
A <- A + DeltaA
Z <- Z + DeltaZ
data <- rbind(data, data.frame(Time = i, "A" = A, "Z" = Z))
}
data$rho <- 0.02
rho <- 0.03 #my second choice
A <- 69
Z <- 1
data2 <- data.frame(Time=0, A = A, Z = Z)
for(i in 1:100){
DeltaA <- -rho*A*(Z/70)^0.5
DeltaZ <- rho*A*(Z/70)^0.5 - Z/15
A <- A + DeltaA
Z <- Z + DeltaZ
data2 <- rbind(data2, data.frame(Time = i, "A" = A, "Z" = Z))
}
data2$rho <- 0.03
rho <- 0.01 #my third choice
A <- 69
Z <- 1
data3 <- data.frame(Time=0, A = A, Z = Z)
for(i in 1:100){
DeltaA <- -rho*A*(Z/70)^0.5
DeltaZ <- rho*A*(Z/70)^0.5 - Z/15
A <- A + DeltaA
Z <- Z + DeltaZ
data3 <- rbind(data3, data.frame(Time = i, "A" = A, "Z" = Z))
}
data3$rho <- 0.01
Data <- rbind(data, rbind(data2,data3))
library(ggplot2)
g <- ggplot(Data,aes(x=Time, y = Z, col = rho, group = rho))
g + geom_line() + theme_bw() + ylab("Number of Students Asleep")
g <- ggplot(Data,aes(x=Time, y = 70-Z, col = rho, group = rho))
g + geom_line() + theme_bw() + ylab("Number of Students Awake")
sleepers <- data.frame(Minutes = c(5, 7, 10, 12, 14, 16, 18, 20, 21, 23, 25, 27, 28, 30, 32, 33, 35, 37, 39, 41, 42, 44, 46, 48), Asleep = c(2, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8))
knitr::kable(sleepers)
medianAD <- function(y, yhat) median(abs(y - yhat)) #calculate the median absolute deviation per instruction
objectiveFunction <- function(x, obs, dist = "medianAD") {
##model the values
rho <- x
A <- 69
Z <- 1
sim <- data.frame(Time=0, A = A, Z = Z)
for(i in 1:100){
DeltaA <- -rho*A*(Z/70)^0.5
DeltaZ <- rho*A*(Z/70)^0.5 - Z/15
A <- A + DeltaA
Z <- Z + DeltaZ
sim <- rbind(sim, data.frame(Time = i, "A" = A, "Z" = Z))
}
eval(call(dist, obs$Asleep, sim$Z[sim$Time %in% obs$Minutes]))
}
fit1 <- optim(0.02, objectiveFunction, obs = sleepers, method = "Brent", lower = 0, upper = 0.1)
fit1$par #best value of rho
fit1$convergence #check convergence
chebyshev <- function(y, yhat) max(abs(y - yhat))
llpois <- function(y, yhat) sum(dpois(y, yhat, log = T))
fit2 <- optim(0.02, objectiveFunction, obs = sleepers, dist = "chebyshev", method = "Brent", lower = 0, upper = 0.1)
fit3 <- optim(0.02, objectiveFunction, obs = sleepers, dist = "llpois", method = "Brent", lower = 0, upper = 0.1, control = list(fnscale = -1))
c("rho"=fit2$par,"conv"=fit2$convergence)
c("rho"=fit3$par,"conv"=fit3$convergence)
FitData <- data.frame(Time = 0, A = 0, Z = 0, rho = 0)
FitData <- FitData[0,]
for(rho in c(fit1$par,fit2$par,fit3$par)){
A <- 69
Z <- 1
fitdata <- data.frame(Time=0, A = A, Z = Z)
for(i in 1:50){
DeltaA <- -rho*A*(Z/70)^0.5
DeltaZ <- rho*A*(Z/70)^0.5 - Z/15
A <- A + DeltaA
Z <- Z + DeltaZ
fitdata <- rbind(fitdata, data.frame(Time = i, "A" = A, "Z" = Z))
}
fitdata$rho <- rho
FitData <- rbind(FitData,fitdata)
}
g <- ggplot(FitData,aes(x=Time, y = Z, col = as.factor(rho), group = rho))
g + geom_line() + theme_bw() + ylab("Number of Students Asleep") + geom_point(data=sleepers, aes(x = Minutes, y = Asleep), col = "black") + scale_color_discrete(name = "Method", labels = c("Chebyshev","Poisson", "Median AD"))
set.seed(132412)
hrothgar.attack <- function(){
hit.die <- sample(1:20,1)
dmg <- sample(1:6,1)
if(hit.die > 17) return(dmg*2)
if(hit.die > 11) return(dmg)
0
}
grimweard.attack <- function(){
hit.die <- sample(1:10,1)
dmg <- sum(sample(1:4,2, replace = T))
if(hit.die > 6) return(dmg)
0
}
CDF.hrothgar <- ecdf(replicate(10000,hrothgar.attack()))
rdmg.hrothgar <- function(n=1) unname(quantile(CDF.hrothgar, runif(n)))
CDF.grimweard <- ecdf(replicate(10000,grimweard.attack()))
rdmg.grimweard <- function(n=1) unname(quantile(CDF.grimweard, runif(n)))
h1 <- hist(rdmg.hrothgar(1000),main = "Hrothgar's Damage PDF", xlab = "Damage", breaks = 0:13,right=F, xaxt = "n")
axis(1, at = h1$mids, labels = 0:12)
h2 <- hist(rdmg.grimweard(1000),main = "Grimweard's Damage PDF", xlab = "Damage", breaks = 0:9, right=F, xaxt ="n")
axis(1, at = h2$mids, labels = 0:8)
battle <- function(){
hrothgar <- 25
grimweard <- 15
#generate random damage and then look at the cumulative sum
cumdmg.hrothgar <- cumsum(rdmg.hrothgar(100))
cumdmg.grimweard <- cumsum(rdmg.grimweard(100))
#figure out how many turns it took for the cumulative sum to exceed the respective HP values
nToWin.hrothgar <- sum(cumdmg.hrothgar < grimweard) + 1
nToWin.grimweard <- sum(cumdmg.grimweard < hrothgar) + 1
#check the number of turns and determine who won; if turn count is equal, pick someone randomly
if(nToWin.grimweard == nToWin.hrothgar){ return(data.frame("Winner" = sample(c("Hrothgar", "Grimweard"),1), Attacks = nToWin.grimweard)) }
if(nToWin.grimweard < nToWin.hrothgar) return(data.frame("Winner" = "Grimweard", Attacks = nToWin.grimweard))
return(data.frame("Winner" = "Hrothgar", Attacks = nToWin.hrothgar))
}
#FIGHT!!!!
results <- battle()
for(i in 1:999) results <- rbind(results, battle())
table(results$Winner)/1000
mean(results$Attacks[results$Winner == "Hrothgar"])
quantile(results$Attacks[results$Winner == "Hrothgar"], c(0.025,0.5,0.975))
mean(results$Attacks[results$Winner == "Grimweard"])
quantile(results$Attacks[results$Winner == "Grimweard"], c(0.025,0.5,0.975))
#thresh is the threshold at which Hrothgar runs
battle2 <- function(thresh = 0){
hrothgar <- 25
grimweard <- 15
cumdmg.hrothgar <- cumsum(rdmg.hrothgar(100))
cumdmg.grimweard <- cumsum(rdmg.grimweard(100))
#Note that Grimweard's winning condition is now based upon subtracting the threshold from his HP
#if thresh = 0, we should get the same results as our first simulations
nToWin.hrothgar <- sum(cumdmg.hrothgar < grimweard) + 1
nToWin.grimweard <- sum(cumdmg.grimweard < hrothgar - thresh) + 1
#similar logic as previous function, but we track fleeing and death now
if(nToWin.hrothgar < nToWin.grimweard) return(data.frame("Winner" = c("Hrothgar"), Flee  = F, Killed= F))
if(sample(c("Hrothgar","Grimweard"),1) == "Hrothgar" & nToWin.grimweard == nToWin.hrothgar) return(data.frame("Winner" = c("Hrothgar"), Flee  = F, Killed= F))
return(data.frame("Winner" = "Grimweard", Flee = cumdmg.grimweard[nToWin.grimweard] >= hrothgar - thresh, Killed = cumdmg.grimweard[nToWin.grimweard+1] >= hrothgar))
}
#now loop over all possible thresholds to look for optimal strategy
strategy <- data.frame(threshold = 0:24, winning.percent = NA, saved.death = NA)
for(f in strategy$threshold){
results2 <- battle2(f)
for(i in 1:999) results2 <- rbind(results2, battle2(f))
strategy$winning.percent[f+1] <- sum(results2$Winner == "Hrothgar")/1000
summaryTab <- xtabs(rep(1, 1000) ~ Flee  + Killed + Winner, data = results2)
strategy$saved.death[f+1] <- sum(summaryTab["TRUE","FALSE","Grimweard"])/sum(summaryTab["TRUE",,"Grimweard"])
}
knitr::kable(strategy)
ls()
knitr::kable(strategy)
reticulate::repl_python()
