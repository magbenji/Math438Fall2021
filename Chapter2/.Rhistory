py_install("scikit-learn")
reticulate::repl_python()
py_install("statsmodels")
reticulate::repl_python()
py_install("matplotlib")
py_config()
reticulate::repl_python()
getwd()
data <- read.csv("Observations.csv", header = T)
#### Plot the data ---------
### Let's explore the data visually
plot(data, type="l")
### Data seem to be exponential of some kind
### Try plotting log y
plot(data,type="l", log="y")
### Log y didn't fix it. Try log x instead.
plot(data,type="l", log="x")
### Log x and log y didn't work. Try log-log instead.
plot(data,type="l", log="xy")
### What model does this suggest in the untransformed variables x,y?
#### Creating a basic model -----
### That produced a nice line!
### Let's transform the data
tdata <- log(data)
### Fit the model
summary(m <- lm(Observation ~ Input, tdata))
### Write down the model for the untransformed variables!
exp(coef(m)[1])
#### A slightly different model ----
### We can also fit this using a altered "link" function in glm, try it!
summary(m2 <- glm(Observation ~ log(Input), data, family = gaussian(link = "log")))
#Compare the predictions of the 2 models
plot(predict(m2), predict(m))
abline(a=0,b=1) #add a 1-to-1 line for convenience
#### Comparing models ----
### Let's choose between the models and compare coefficients
AIC(m,m2)
coef(m)
coef(m2)
anova(m1,m2)
anova(m,m2)
summary(anova(m,m2))
summary(aov(m,m2))
aov(m,m2)
predict(m)
(exp(predict(m)) - data$Observation)^2
sum(exp(predict(m)) - data$Observation)^2)
sum((exp(predict(m)) - data$Observation)^2)
predict(m2)
predict(m2, type="response")
sum((predict(m2, type="response") -  data$Observation)^2)
m2$residuals
sum(m2$residuals)^2
reticulate::repl_python()
set.seed(julian(Sys.Date()))
x <- runif(100,0,10)
x
reticulate::repl_python()
y <- 4 + (x-2)^2 + runif(100,-1,1)*0.5*x
### Visualized the data
plot(y~x)
xy.lo <- data.frame(x = seq(min(x),max(x),len = 100), y = predict(loess(y~x),data.frame(x=seq(min(x),max(x),len = 100))))
lines(xy.lo)
reticulate::repl_python()
round(min(xy.lo$y))
round(x[which.min(y)])
#### Modeling the data ----
### let's transform the variables
yp <- y - 4
xp <- x - 2
### now plot the variables
### why is using abs() justified?
plot(abs(yp)~abs(xp),log="xy")
### let's try our linear model
reticulate::repl_python()
library(reticulate)
py_install("statsmodels")
reticulate::repl_python()
py_config()
py_install("statmodels")
py_install("statsmodels")
reticulate::repl_python()
bob <- 42
reticulate::repl_python()
py_run_string("bob = 42")
py$results2
py$results2
py$data
library(reticulate)
py$data
py$data$Input
reticulate::repl_python()
library(reticulate)
py$data
py$tdata
bob <- 23
reticulate::repl_python()
class <- c("S","T","G", "A", "J")
sample(class)
reticulate::repl_python()
#######------- Circle vs. Circle
library(TDA)
library(igraph)
library(dplyr)
tropicalEncoding <- function(barcodeMatrix){
require(lpSolve)
nR <- nrow(barcodeMatrix)
barcodeMatrix <- as.matrix(barcodeMatrix)
b.obj <- as.vector(t(as.matrix(barcodeMatrix))) #coefficients of the objective function (x1, d1, x2, d2, ... , xn, dn)
b.dir <- c(rep("<=", nR), "==", "==", rep("<=", nR)) #direction of contraints
#matrix needs to m x n columns (23 x 2 = 46 columns)  and
#2*(m + 1) rows (2 * (23 + 1) = 48 rows)
b.con <- matrix(0, nrow = 2*(nR+1), ncol = prod(dim(barcodeMatrix)))
for(i in 1:nR) b.con[i,1:2 + (i - 1)*2] <- as.numeric(barcodeMatrix[i,])
b.con[nR+1, ] <- rep(c(1,0), nR)
b.con[nR+2, ] <- rep(c(0,1), nR)
for(i in 1:nR) b.con[i + nR + 2,1:2 + (i - 1)*2] <- c(1,-1)
results <- data.frame("i" = NA, "j" = NA, "val" = NA)[0,]
for(i in 0:nR){
for(j in 0:nR){
if(i + j == 0 | i + j > nR) next
b.rhs <- c(rowSums(barcodeMatrix), j, i+j, rep(0, nR))
b.sol <- lp("max", b.obj, b.con, b.dir, b.rhs, all.bin = T)
results <- rbind(results, data.frame("i" = i, "j" = j, "val" = b.sol$objval))
}
}
results$val
}
Circle <- function(r,theta) c(r * cos(theta), r * sin(theta))
Square <- function(l){
p <- c(runif(1,-l/2,l/2), sample(c(-l/2,l/2),1))
if(rbinom(1,1,0.5)) return(rev(p))
p
}
findEmbeddedCircle <- function(r,n, error=F, clean=F, returnRips = F, manifoldOnly = F){
circ <- t(replicate(n,Circle(r,runif(1,0,2*pi))))
if(error) circ <- apply(circ, 1:2, function(x) rnorm(1, x, error))
if(manifoldOnly) return(circ)
rd <- ripsDiag(circ, dist = "euclidean", maxdimension = 1, maxscale = 200)$diagram
if(returnRips) return(rd)
rd0 <- rd[rd[,1] == 0,2:3]
rd0 <- rd0[-1,]
rd0 <- tropicalEncoding(rd0)
if(clean) rd0 <- rd0[rd0 > (median(rd0) - IQR(rd0)) & rd0 < (median(rd0) + IQR(rd0))]
rd0 <- list("manifold" = circ, "rips" = rd, "embedding" = rd0)
class(rd0) <- c("TropicalEmbedding", class(rd0))
rd0
}
mu2_15 <- replicate(100, mean(findEmbeddedCircle(2,15, clean = T)$embedding))
#######------- Circle vs. Circle
library(TDA)
library(igraph)
library(dplyr)
mu2_15 <- replicate(100, mean(findEmbeddedCircle(2,15, clean = T)$embedding))
mu2_15_e1 <- replicate(100, mean(findEmbeddedCircle(2,15, error = 1, clean = T)$embedding))
mu2_15_e2 <- replicate(100, mean(findEmbeddedCircle(2,15, error = 2, clean = T)$embedding))
mu2_15_e0_5 <- replicate(100, mean(findEmbeddedCircle(2,15, error = 0.5, clean = T)$embedding))
mu2_15_e0_25 <- replicate(100, mean(findEmbeddedCircle(2,15, error = 0.25, clean = T)$embedding))
boxplot(mu2_15, mu2_15_e1, mu2_15_e2, names= c("No error", "SD = 1", "SD = 2"), main = "Circle, r = 2 with error (100 replicates)",
ylab = "Mean of Embedded Coordinates")
rowMeans(replicate(1000,quantile(sample(mu2_15) - sample(mu2_15_e1), c(0.025,0.975))))
rowMeans(replicate(1000,quantile(sample(mu2_15) - sample(mu2_15_e0_5), c(0.025,0.975))))
rowMeans(replicate(1000,quantile(sample(mu2_15) - sample(mu2_15_e0_25), c(0.025,0.975))))
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
seqR <- seq(1,5,0.1)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 15, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 30, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 30, error = 0.5, returnRips = T)
seqR <- seq(1,5,0.1)
findEmbeddedCircle(10, 30, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 30, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 30, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 30, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 30, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 30, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 30, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 30, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 30, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 30, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 30, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 30, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 30, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 30, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 30, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 30, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 30, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.5, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
findEmbeddedCircle(10, 50, error = 0.8, returnRips = T)
reticulate::repl_python()
